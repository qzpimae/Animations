<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GQZ_Asteroids</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
    }

    canvas {
      display: block;
      border: 1px solid white;
    }
  </style>
</head>

<body>
  <canvas id="arrowCanvas"></canvas>

  <script>
    const canvas = document.getElementById('arrowCanvas');
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    let x = canvas.width / 2;
    let y = canvas.height / 2;
    let velocityX = 0;
    let velocityY = 0;
    let angle = Math.PI / 2;
    const arrowWidth = 10;
    const arrowHeight = 20;
    const thrustPower = 0.2;
    const brakePower = 0.005;
    const friction = 0.98;
    const projectileCooldownTime = 200;
    let projectileCooldown = 0;
    const projectiles = [];
    const projectileRadius = 1.5;
    const projectileSpeed = 5;
    const asteroids = [];
    const asteroidMaxSize = 32;
    const asteroidMinSize = 2;
    const maxFadeFrames = 20; // Adjust this value as needed
    let health = 100;
    let points = 0;
    let totalAsteroidMass = 0; // Added for total asteroid mass
    const keys = {};
    let lastTimestamp = 0;

    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);

    function handleKeyDown(e) {
      keys[e.key] = true;

      if (e.key === ' ' && Date.now() > projectileCooldown) {
        const projectile = {
          x,
          y,
          size: projectileRadius,
          velocityX: Math.cos(angle) * projectileSpeed * 2,
          velocityY: Math.sin(angle) * projectileSpeed * 2,
        };
        projectiles.push(projectile);
        projectileCooldown = Date.now() + projectileCooldownTime;
      }
    }

    function handleKeyUp(e) {
      keys[e.key] = false;
    }

    function update(timestamp) {
      requestAnimationFrame(update);

      if (timestamp - lastTimestamp < 1000 / 60) {
        return;
      }
      lastTimestamp = timestamp;

      ctx.clearRect(0, 0, canvas.width, canvas.height);

      const cosAngle = Math.cos(angle);
      const sinAngle = Math.sin(angle);

      for (const asteroid of asteroids) {
        asteroid.age++;

        let fadeFactor = 1;
        if (asteroid.age < maxFadeFrames) {
          fadeFactor = asteroid.age / maxFadeFrames;
        }

        const grayColor = Math.floor(255 * fadeFactor);
        const borderColor = 10; // Black border

        ctx.beginPath();
        ctx.arc(asteroid.x, asteroid.y, asteroid.size, 0, Math.PI * 2);
        ctx.fillStyle = `rgb(${grayColor}, ${grayColor}, ${grayColor})`;
        ctx.strokeStyle = 'black';
        ctx.lineWidth = borderColor;
        ctx.fill();
        ctx.stroke();
        ctx.closePath();
      }

      for (const asteroid of asteroids) {
        if (asteroid.age >= maxFadeFrames) {
          asteroid.x = (asteroid.x + asteroid.velocityX + canvas.width) % canvas.width;
          asteroid.y = (asteroid.y + asteroid.velocityY + canvas.height) % canvas.height;
        }
      }

      for (let i = projectiles.length - 1; i >= 0; i--) {
        const projectile = projectiles[i];
        projectile.x += projectile.velocityX;
        projectile.y += projectile.velocityY;

        if (
          projectile.x < 0 ||
          projectile.x > canvas.width ||
          projectile.y < 0 ||
          projectile.y > canvas.height
        ) {
          projectiles.splice(i, 1);
        }
      }

      if (keys['ArrowUp']) {
        velocityX += cosAngle * thrustPower;
        velocityY += sinAngle * thrustPower;
      }
      if (keys['ArrowDown']) {
        velocityX *= 1 - brakePower;
        velocityY *= 1 - brakePower;
      }
      if (keys['ArrowLeft']) {
        angle -= 0.075;
      }
      if (keys['ArrowRight']) {
        angle += 0.075;
      }

      velocityX *= friction;
      velocityY *= friction;

      x = (x + velocityX + canvas.width) % canvas.width;
      y = (y + velocityY + canvas.height) % canvas.height;

      drawArrow();
      handleCollisions();
      updateAsteroids();
      updateProjectiles();
      showHUD();
    }

    function drawArrow() {
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(angle);
      ctx.beginPath();
      ctx.moveTo(-arrowHeight / 4, -arrowWidth / 4);
      ctx.lineTo(-arrowHeight / 4, arrowWidth / 4);
      ctx.lineTo(arrowHeight / 4, 0);
      ctx.closePath();
      ctx.fillStyle = 'white';
      ctx.fill();
      ctx.restore();
    }

    function handleCollisions() {
      totalAsteroidMass = 0;

      for (let i = asteroids.length - 1; i >= 0; i--) {
        const asteroid = asteroids[i];
        totalAsteroidMass += asteroid.size; // Calculate total asteroid mass

        const distanceShipAsteroid = Math.hypot(x - asteroid.x, y - asteroid.y);

        // Check if the asteroid is done fading in
        if (asteroid.age >= maxFadeFrames) {
          if (distanceShipAsteroid < arrowWidth / 2 + asteroid.size / 2) {
            health -= 10;
            asteroids.splice(i, 1);
          }
        }

        for (let j = projectiles.length - 1; j >= 0; j--) {
          const projectile = projectiles[j];
          const distance = Math.hypot(projectile.x - asteroid.x, projectile.y - asteroid.y);

          // Check if the asteroid is done fading in
          if (asteroid.age >= maxFadeFrames) {
            if (distance < projectileRadius + asteroid.size) {
              splitAsteroid(asteroid);
              asteroids.splice(i, 1);
              projectiles.splice(j, 1);
              points += 10;
            }
          }
        }
      }
    }

    function updateAsteroids() {
      for (const asteroid of asteroids) {
        if (asteroid.age >= maxFadeFrames) {
          ctx.beginPath();
          ctx.arc(asteroid.x, asteroid.y, asteroid.size, 0, Math.PI * 2);
          ctx.fillStyle = 'gray';
          ctx.fill();
          ctx.closePath();
        }
      }
    }

    function updateProjectiles() {
      // Update projectile positions
      for (let i = projectiles.length - 1; i >= 0; i--) {
        const projectile = projectiles[i];
        projectile.x += projectile.velocityX;
        projectile.y += projectile.velocityY;

        // Remove projectiles that are out of bounds
        if (
          projectile.x < 0 ||
          projectile.x > canvas.width ||
          projectile.y < 0 ||
          projectile.y > canvas.height
        ) {
          projectiles.splice(i, 1);
        }
      }

      // Draw projectiles
      for (let i = 0; i < projectiles.length; i++) {
        const projectile = projectiles[i];
        ctx.beginPath();
        ctx.arc(projectile.x, projectile.y, projectile.size, 0, Math.PI * 2);
        ctx.fillStyle = 'red';
        ctx.fill();
        ctx.closePath();
      }
    }

    function showHUD() {
      // Draw health and points
      ctx.fillStyle = 'white';
      ctx.font = '20px Arial';
      ctx.fillText(`Health: ${health}`, 20, 30);

      // Display total asteroid sizes in the middle
      const totalAsteroidSizes = asteroids.reduce((sum, asteroid) => sum + asteroid.size, 0);
      ctx.fillText(`Asteroid Mass: ${totalAsteroidSizes.toFixed(2)}`, canvas.width / 2 - 80, 30);

      ctx.fillText(`Points: ${points}`, canvas.width - 120, 30);

      // Draw projectile cooldown information
      const cooldownPercentage = Math.max(0, (projectileCooldown - Date.now()) / projectileCooldownTime);
      const cooldownColor = `rgb(${255 * (1 - cooldownPercentage)}, ${255 * cooldownPercentage}, 0)`;

      const barWidth = 100;
      const barHeight = 10;
      const barX = (canvas.width - barWidth) / 2;
      const barY = canvas.height - 40;

      // Draw white border
      ctx.fillStyle = 'white';
      ctx.fillRect(barX - 2, barY - 2, barWidth + 4, barHeight + 4);

      // Draw filled portion based on cooldownPercentage
      ctx.fillStyle = cooldownColor;
      ctx.fillRect(barX, barY, barWidth * cooldownPercentage, barHeight);
    }

    function spawnAsteroid() {
      const minPower = 1; // Minimum power of 2 (2^1)
      const maxPower = 5; // Maximum power of 2 (2^5)

      const power = Math.floor(Math.random() * (maxPower - minPower + 1)) + minPower;
      const size = Math.pow(2, power);

      const asteroid = {
        x: Math.random() * canvas.width,
        y: Math.random() * canvas.height,
        size: size,
        velocityX: Math.random() - 0.5,
        velocityY: Math.random() - 0.5,
        age: 0, // Initialize age to 0
      };

      asteroids.push(asteroid);
    }

    function splitAsteroid(asteroid) {
      if (asteroid.size > asteroidMinSize * 2) {
        for (let k = 0; k < 2; k++) {
          const newAsteroid = {
            x: asteroid.x,
            y: asteroid.y,
            size: asteroid.size / 2,
            velocityX: asteroid.velocityX + (Math.random() - 0.5),
            velocityY: asteroid.velocityY + (Math.random() - 0.5),
            age: maxFadeFrames, // Set age to maxFadeFrames for split asteroids
          };
          asteroids.push(newAsteroid);
        }
      }
    }

    function gradualAsteroidSpawn() {
      const maxMass = 100; // Adjust this value as needed
      const respawnRate = 0.5; // Adjust this value for respawn speed

      const currentMass = asteroids.reduce((sum, asteroid) => sum + asteroid.size, 0);

      // Calculate spawn rate based on the current mass and respawn rate
      const spawnRate = 1 - currentMass / maxMass;
      const adjustedSpawnRate = spawnRate * respawnRate;

      // Adjust spawn probability based on adjustedSpawnRate
      if (Math.random() < adjustedSpawnRate) {
        spawnAsteroid();
      }

      // Schedule the next asteroid spawn
      setTimeout(gradualAsteroidSpawn, 1000);
    }

    function spawnInitialAsteroids(count) {
      for (let i = 0; i < count; i++) {
        spawnAsteroid();
      }
    }

    spawnInitialAsteroids(3);
    requestAnimationFrame(update);
    gradualAsteroidSpawn();
  </script>
</body>

</html>
