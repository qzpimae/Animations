///HTML

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>SADNOISE</title>
    <!-- <script type="text/javascript" src="toxiclibs.min.js"></script> -->
    <style type="text/css">
    
        body {
            background-color: rgb(0, 0, 0);
            margin: 0px;
            overflow: hidden;
            height: 100vh;
        }
        canvas {
            display: block;
            position: static;
            top: 0px;
            left: 0px;
        }

    </style>

</head>
<body >


    
    <script type="text/javascript" >

        class SimplexNoise {
            constructor() {
                // To remove the need for index wrapping, double the permutation table length
                this.perm = new Array(512);
                this.grad3 = [
                    [1, 1, 0], [-1, 1, 0], [1, -1, 0], [-1, -1, 0],
                    [1, 0, 1], [-1, 0, 1], [1, 0, -1], [-1, 0, -1],
                    [0, 1, 1], [0, -1, 1], [0, 1, -1], [0, -1, -1]
                ];

                this.seed(0);
            }

            seed(seed) {
                if (seed > 0 && seed < 1) {
                    // Scale the seed for consistency
                    seed *= 65536;
                }

                seed = Math.floor(seed);

                if (seed < 256) {
                    seed |= seed << 8;
                }

                for (let i = 0; i < 256; i++) {
                    let v;
                    if (i & 1) {
                        v = this.perm[i] ^ (seed & 255);
                    } else {
                        v = this.perm[i] ^ ((seed >> 8) & 255);
                    }

                    this.perm[i + 256] = this.perm[i] = v;
                }
            }



            noise(xin, yin) {
                // Noise contributions from the three corners
                let n0, n1, n2;

                // Skewing/Unskewing factors for 2D
                const F2 = 0.5 * (Math.sqrt(3.0) - 1.0);
                const G2 = (3.0 - Math.sqrt(3.0)) / 6.0;

                // Noise contributions from the first corner
                let s = (xin + yin) * F2;
                let i = Math.floor(xin + s);
                let j = Math.floor(yin + s);
                const t = (i + j) * G2;
                const X0 = i - t; // Unskew the cell origin back to (x, y) space
                const Y0 = j - t;
                const x0 = xin - X0; // The x, y distances from the cell origin
                const y0 = yin - Y0;

                // For the 2D case, the simplex shape is an equilateral triangle.
                // Determine which simplex we are in.
                let i1, j1; // Offsets for second (middle) corner of simplex in (i, j) coords
                if (x0 > y0) {
                    i1 = 1;
                    j1 = 0;
                } else {
                    i1 = 0;
                    j1 = 1;
                }

                // A step of (1, 0) in (i, j) means a step of (1 - c, -c) in (x, y), and
                // a step of (0, 1) in (i, j) means a step of (-c, 1 - c) in (x, y), where
                // c = (3 - sqrt(3))/6

                const x1 = x0 - i1 + G2; // Offsets for middle corner in (x, y) unskewed coords
                const y1 = y0 - j1 + G2;
                const x2 = x0 - 1.0 + 2.0 * G2; // Offsets for last corner in (x, y) unskewed coords
                const y2 = y0 - 1.0 + 2.0 * G2;

                // Work out the hashed gradient indices of the three simplex corners
                const ii = i & 255;
                const jj = j & 255;
                const gi0 = this.perm[ii + this.perm[jj]] % 12;
                const gi1 = this.perm[ii + i1 + this.perm[jj + j1]] % 12;
                const gi2 = this.perm[ii + 1 + this.perm[jj + 1]] % 12;

                // Calculate the contribution from the three corners
                let t0 = 0.5 - x0 * x0 - y0 * y0;
                if (t0 < 0) {
                    n0 = 0.0;
                } else {
                    t0 *= t0;
                    n0 = t0 * t0 * this.dot(this.grad3[gi0], x0, y0);
                }

                let t1 = 0.5 - x1 * x1 - y1 * y1;
                if (t1 < 0) {
                    n1 = 0.0;
                } else {
                    t1 *= t1;
                    n1 = t1 * t1 * this.dot(this.grad3[gi1], x1, y1);
                }

                let t2 = 0.5 - x2 * x2 - y2 * y2;
                if (t2 < 0) {
                    n2 = 0.0;
                } else {
                    t2 *= t2;
                    n2 = t2 * t2 * this.dot(this.grad3[gi2], x2, y2);
                }

                // Add contributions from each corner to get the final noise value.
                // The result is scaled to return values in the interval [-1,1].
                return 70.0 * (n0 + n1 + n2);
            }

            dot(g, x, y) {
                return g[0] * x + g[1] * y;
            }
        }



        const Noise = new SimplexNoise(),
            pi = Math.PI,
            sqrt = Math.sqrt,
            pow = Math.pow;
        let seed = Math.random()*100;
        //VARS FOR CANVAS AND TIMING EVENTS
        let canvas = document.createElement('canvas'),
            context = canvas.getContext('2d'),
            width = canvas.width = window.innerWidth,
            height = canvas.height = window.innerHeight,
            time = 0,
            timeMax = Infinity,
            timeForward = true,
            speed = .37,
            clearScreen = true,
            pauseAnimation = false,
            szMlt = .5,
            layers = 2,
            layerMult = 1,
            rotation = 0; 


        // context.strokeStyle = 'white';
        context.strokeStyle = "rgba(1, 1, 1, 0)";
        // context.fillStyle = 'white';

        context.lineWidth = 1;

        canvas.style = `display: block;
                        position: static;
                        top: 0px;
                        left: 0px;
                        cursor: none;
                        margin:auto;
                        background-color: black`;

        document.body.style = `margin: 0`;

        document.body.appendChild(canvas)

        //USER INPUT EVENT LISTENER
        document.addEventListener('keydown', userInputEvent, false);

        //USER INPUT LOGIC
        function userInputEvent(input) {
            // console.log(input.code);
            switch (input.code) {
                case 'KeyZ':
                clearScreen = !clearScreen;
                break;
                case 'Space':
                    pauseAnimation = !pauseAnimation;
                    if (!pauseAnimation) {
                        render()
                    }
                break;
                case 'ArrowUp':
                    speed = speed < 10 ? speed+.01 : 10;
                break;
                case "ArrowDown":
                    speed = speed > .002 ? speed-.01 : .002;
                break;
                case 'KeyQ':
                    layerMult = layerMult < 50 ? layerMult+.01 : 50;
                break;
                case "KeyA":
                    layerMult = layerMult > .005 ? layerMult-.01 : .005;
                break;
                case 'KeyO':
                    layers = layers < 100 ? layers+1 : 100;
                break;
                case 'KeyL':
                    layers = layers > 1 ? layers-1 : 1;
                break;
                case 'KeyT':
                    speed = speed < 10 ? speed+.1 : 10;
                break;
                case 'KeyG':
                    speed = speed > .002 ? speed-.1 : .002;
                break;
                case 'KeyD':
                    szMlt = szMlt < 10 ? szMlt+.01 : 10;
                break;
                case 'KeyC':
                    szMlt = szMlt > .002 ? szMlt-.01 : .002;
                break;

                case 'KeyP':
                    rotation += 1;
                    break;
                case 'Semicolon': 
                    rotation -= 1;
                    break;

                case 'Slash':
                    time = 0;
                    break;
                
                case 'KeyM': 
                    console.log(`
                    case 'ArrowUp':
                    speed = speed < 10 ? speed+.01 : 10;
                break;
                case "ArrowDown":
                    speed = speed > .002 ? speed-.01 : .002;
                break;
                case 'KeyQ':
                    layerMult = layerMult < 50 ? layerMult+.01 : 50;
                break;
                case "KeyA":
                    layerMult = layerMult > .005 ? layerMult-.01 : .005;
                break;
                case 'KeyO':
                    layers = layers < 100 ? layers+1 : 100;
                break;
                case 'KeyL':
                    layers = layers > 1 ? layers-1 : 1;
                break;
                case 'KeyT':
                    speed = speed < 10 ? speed+.1 : 10;
                break;
                case 'KeyG':
                    speed = speed > .002 ? speed-.1 : .002;
                break;
                case 'KeyD':
                    szMlt = szMlt < 10 ? szMlt+.1 : 10;
                break;
                case 'KeyC':
                    szMlt = szMlt > .002 ? szMlt-.1 : .002;
                break;
            }
                    `);
            }
        }

        //SET THE CANVAS ORIGIN TO THE MIDDLE OF THE WINDOW
            //   context.translate(width/2, height/2)   

        //ANIMAITON CYCLE

                render()

                function render() {

                if (timeForward && time < timeMax) {
                    time+=speed
                } else if (timeForward && time >= timeMax) {
                    setTimeout(()=>{timeForward = false;}, 100)
                } else if (!timeForward && time > 1) {
                    time-=speed
                } else if ( time <= 1){
                    timeForward = true;
                    time = 1.1
                    seed = Math.random()  
                }

                if(clearScreen) clearFullScreen()

                    
                for (let i = 0; i < layers; i++) {

                    //    context.fillStyle = i % 2 != 0 && !clearFullScreen ? '100' : '0'
                    //    context.strokeStyle = i % 2 != 0 && !clearFullScreen ? '100' : '0'
                    createImg(time+(i*layerMult), i)
                    
                }
                if (!pauseAnimation) {
                    setTimeout(window.requestAnimationFrame, 0, render)
                }
            }

        function createImg(s, b) { 

            context.save();

                context.translate(width/2, height/2)

                context.rotate(rotation/180);

                context.translate(-width/2, -height/2)

                // console.log(!clearScreen)

            
                for (let x = 0; x < width/20+1; x+=.7) {
                    
                    for (let y = 0; y < height/20+1; y+=.7) {

                        const
                        noiseX = x/30 + s/50, 
                        noiseY = y/30,
                        distance = sqrt( pow((x*20)-(width/2), 2) +  pow((y*20)-(height/2), 2) ),
                        N1 = Noise.noise(noiseX, noiseY),
                        N2 = Noise.noise(noiseY,noiseX),
                        N3 = Noise.noise(noiseY/2,noiseY/2),
                        N4 = Noise.noise(noiseX/2,noiseX/2),

                        radius = 4-distance/300,
                        X = x*20+ (N1*(2+time/10)+N2*(2+time/10)) * (1+N4),
                        Y = y*20+ (N1*(2+time/10)-N2*(2+time/10)) * (1+N3);

                        context.fillStyle =  `hsl(0, 0%, ${(b % 2 != 0 && !clearScreen ? 0: 100)-distance/5}%)`;
                        context.beginPath()
                        context.arc(X, Y, Math.abs(radius*szMlt), 0, pi*2)
                        context.fill()
                                
                    }
                    
                }


            // context.translate(-width/2, -height/2)

            context.restore();

        }

        function clearFullScreen() {

            context.save();
            context.setTransform(1, 0, 0, 1, 0, 0);
            context.clearRect(0, 0, canvas.width, canvas.height);
            context.restore();
            
        }

        function mapNumber (number, min1, max1, min2, max2) {
            return ((number - min1) * (max2 - min2) / (max1 - min1) + min2);
        };




    </script>
    
    
    </body>
</html>

