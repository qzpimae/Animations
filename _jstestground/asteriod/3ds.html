<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>08_23 </title>
    <script type="text/javascript" src="toxiclibs.min.js"></script>
    <style type="text/css">
    
        body {
            background-color: rgb(0, 0, 0);
            margin: 0px;
            overflow: hidden;
            height: 100vh;
        }
        canvas {
            display: block;
            position: static;
            top: 0px;
            left: 0px;
        }

    </style>

</head>
    <body >
        <script>
            //this file uses the simplex noise algorithm from a library

            const Noise = toxi.math.noise.simplexNoise.noise,
                pi = Math.PI,
                sqrt = Math.sqrt,
                pow = Math.pow;

            let seed = Math.random()*1000,
                mosPos = {
                    x: 1000,
                    y: 1000,
                };
            //VARS FOR CANVAS AND TIMING EVENTS
            let canvas = document.createElement('canvas'),
                context = canvas.getContext('2d'),
                width = canvas.width = window.innerWidth,
                height = canvas.height = window.innerHeight,
                time = 0,
                timeMax = Infinity,
                timeForward = true,
                speed = 1,
                disMult = 1,
                targetDisMult = .001,
                sizeMult = 20,
                targetSzMult = 10,
                clearScreen = false,
                pauseAnimation = false,
                showLines = true,
                showDots = true,
                inColor = false,
                automated = true,
                lightOff = 0;

            context.strokeStyle = 'white';
            context.fillStyle = 'white';

            context.lineWidth = .5;

            canvas.style = `display: block;
                            position: static;
                            top: 0px;
                            left: 0px;
                            cursor: none;
                            margin:auto;
                            background-color: black`;

            document.body.style = `margin: 0`;

            document.body.appendChild(canvas)

            //USER INPUT EVENT LISTENER
            document.addEventListener('keydown', userInputEvent, false);
            canvas.onmousemove = findObjectCoords;


            canvas.addEventListener('click', ()=>{
                targetSzMult = ranRange(4, 10)
                targetDisMult = ranRange(.0003, 1)
            }, false);


            function logInfo () {
                console.log(`
                
                time = ${time}0,
                timeForward = ${timeForward}true,
                speed ${speed} = .4,
                disMult ${disMult}= 1,
                targetDisMult = ${targetDisMult}20,
                sizeMult = ${sizeMult}20,
                targetSzMult = ${targetSzMult}20,
                clearScreen = true,
                pauseAnimation = false,
                showLines = true,
                showDots = true,
                inColor = false,
                lightOff = ${lightOff}0;
                
                
                `);
            }

            

            // 0.0003482808479138186
            // 69
            // 2
            // 24

            //USER INPUT LOGIC
            function userInputEvent(input) {
                switch (input.code) {
                    case 'Space':
                        pauseAnimation = !pauseAnimation;
                        if (!pauseAnimation) {
                            render()
                        }
                        logInfo()
                    break;
                    case 'ArrowUp':
                        speed = speed < 40 ? speed+.1 : 40;
                    break;
                    case "ArrowDown":
                        speed = speed > .1 ? speed-.1 : .1;
                    break;
                    case 'ArrowLeft':
                        sizeMult = sizeMult < 300 ? sizeMult+.1 : 300;
                    break;
                    case "ArrowRight":
                        sizeMult = sizeMult > .1 ? sizeMult-.1 : .1;
                    break;
                    case 'KeyQ':
                        disMult*=2;
                        // console.log(disMult);
                    break;
                    case 'KeyW':
                        disMult/=2;
                        // console.log(disMult);
                    case 'KeyA':
                        disMult*=1.1;
                        // console.log(disMult);
                    break;
                    case 'KeyS':
                        disMult/=1.1;
                        // console.log(disMult);
                    break;
                    case "KeyL":
                        showLines = !showLines;
                        if (!showDots && !showLines) showDots = true
                    break;
                    case "KeyO":
                        showDots = !showDots;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                
                        if (!showDots && !showLines) showLines = true
                    break;
                    case "KeyZ":
                        clearScreen = !clearScreen;
                    break;
                    case "KeyC":
                        inColor = !inColor;
                    break;
                    case "KeyU":
                        lightOff -= 1;
                        // console.log(light);
                    break;
                    case "KeyI":
                        lightOff += 1;
                    break;
                    }
            }

            //SET THE CANVAS ORIGIN TO THE MIDDLE OF THE WINDOW
                //   context.translate(width/2, height/2)   

            //ANIMAITON CYCLE

                    render()

                    function render() {

                    if (timeForward && time < timeMax) {
                        time+=speed/50
                    } else if (timeForward && time >= timeMax) {
                        setTimeout(()=>{timeForward = false;}, 100)
                    } else if (!timeForward && time > 1) {
                        time-=speed/50
                    } else if ( time <= 1){
                        timeForward = true;
                        time = 1.1
                        seed = Math.random()  
                    }

                    if (automated) {
                        // console.log(lightOff);
                        lightOff = ((Math.cos(time/10)) * 50) - 50
                    }

                    disMult = disMult < targetDisMult ? disMult * 1.0001 : disMult * .9999; 
                    sizeMult =  sizeMult < targetSzMult ? sizeMult * 1.0001 : sizeMult * .9999;

                    if(clearScreen) clearFullScreen()

                    renderMouse()
                        
                    createImg(time)
                    
                    if (!pauseAnimation) {
                        setTimeout(window.requestAnimationFrame, 10, render)
                    }
                }

            function createImg(s) { 

                const limits = {
                    sX: 0,
                    eX: width/sizeMult,
                    sY: 0,
                    eY: height/sizeMult,
                },
                
                points = [];

                    for (let x = limits.sX; x < limits.eX; x++) {

                        points.push([]);
                        
                        for (let y = limits.sY; y < limits.eY; y++) {

                            const
                            distance = sqrt( pow((x*sizeMult)-(width/2), 2) + pow((y*sizeMult)-(height/2), 2) ),
                            noiseX = (x/sizeMult + seed ) + s/100 + (distance/(113377*disMult)), 
                            noiseY = (y/sizeMult + seed ) + s/100 + (distance/113377*disMult),
                            N1 = Noise(noiseX, noiseY),
                            N2 = Noise(noiseY, noiseX),
                            radius = 2+N1+N2 > 1 ? 2+N1+N2 : 1,
                            X = x*sizeMult + (N1*sizeMult-N2*sizeMult),
                            Y = y*sizeMult + (N1*sizeMult+N2*sizeMult)*distance*disMult,

                            point = {x: X, y: Y, r: radius, dis: distance };

                            points[x-limits.sX].push(point)
                                    
                        }
                        
                    }

                    renderPoints(points)

            }

            function renderMouse() {
                context.fillStyle = 'white';                  
                context.beginPath()
                context.arc(mosPos.x, mosPos.y, 2, 0, pi*2)
                context.fill()
            }

            function renderPoints(arr) {

                // const t = Math.ceil(time/sizeMult)

                for (let i = 0; i < arr.length; i++) {

                    for (let j = 0; j < arr[i].length; j++) {
                        
                        const p = arr[i][j];

                        const colorVar = (p.dis/3)*p.r+144

                        // const pColor = `hsl(${colorVar}, 100%, 77%)`;
                        const pColor = `hsl(${colorVar}, ${inColor ? 100 : 0}%, ${(colorVar/4%80)+lightOff}%)`;


                        if (showLines) {
                            const px = 
                                arr[i+1] != undefined 
                                ? arr[i+1][j]   
                                : false;
                            const py = 
                                arr[i][j+1] != undefined 
                                ? arr[i][j+1]   
                                : false;
                            const pxy = 
                                arr[i+1] != undefined 
                                && arr[i+1][j+1] != undefined 
                                ? arr[i+1][j+1] 
                                : false;

                            context.strokeStyle = pColor;                  
                            
                            if (px||py||pxy) {
                                context.beginPath()
                                context.moveTo(p.x,p.y)
                                if (px) context.lineTo(px.x, px.y)
                                if (py) context.lineTo(py.x, py.y)
                                context.lineTo(p.x,p.y)
                                if (pxy) context.lineTo(pxy.x, pxy.y)
                                context.stroke()
                            }
                        }

                        if (showDots) {
                            context.fillStyle = pColor;                  
                            context.beginPath()
                            context.arc(p.x, p.y, p.r, 0, pi*2)
                            context.fill()
                            
                        }

                    }
                }

            }

            function clearFullScreen() {

                context.save();
                context.setTransform(1, 0, 0, 1, 0, 0);
                context.clearRect(0, 0, canvas.width, canvas.height);
                context.restore();
                
            }

            function mapNumber (number, min1, max1, min2, max2) {
                return ((number - min1) * (max2 - min2) / (max1 - min1) + min2);
            };

            function ranRange(min, max) {
                // Ensure min is less than max
                if (min > max) {
                    [min, max] = [max, min];
                }

                // Generate a random number within the range
                const randomNumber = Math.random() * (max - min) + min;

                return randomNumber;
            }


            function findObjectCoords(mouseEvent) {

                let obj = canvas,
                    obj_left = 0,
                    obj_top = 0,
                    xpos,
                    ypos;

            while (obj.offsetParent)
            {
                obj_left += obj.offsetLeft;
                obj_top += obj.offsetTop;
                obj = obj.offsetParent;
            }
            if (mouseEvent)
            {
                xpos = mouseEvent.pageX;
                ypos = mouseEvent.pageY;
            }

            xpos -= obj_left;
            ypos -= obj_top;

            mosPos.x = xpos
            mosPos.y = ypos

            }
        </script>

        
    </body>
</html>