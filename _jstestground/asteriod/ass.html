<!DOCTYPE html>
<html lang="en" data-darkreader-mode="dynamic" data-darkreader-scheme="dark"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8"><style class="darkreader darkreader--fallback" media="screen"></style><style class="darkreader darkreader--text" media="screen"></style><style class="darkreader darkreader--invert" media="screen">.jfk-bubble.gtx-bubble, .captcheck_answer_label > input + img, span#closed_text > img[src^="https://www.gstatic.com/images/branding/googlelogo"], span[data-href^="https://www.hcaptcha.com/"] > #icon, #bit-notification-bar-iframe, ::-webkit-calendar-picker-indicator {
    filter: invert(100%) hue-rotate(180deg) brightness(65%) !important;
}</style><style class="darkreader darkreader--inline" media="screen">[data-darkreader-inline-bgcolor] {
  background-color: var(--darkreader-inline-bgcolor) !important;
}
[data-darkreader-inline-bgimage] {
  background-image: var(--darkreader-inline-bgimage) !important;
}
[data-darkreader-inline-border] {
  border-color: var(--darkreader-inline-border) !important;
}
[data-darkreader-inline-border-bottom] {
  border-bottom-color: var(--darkreader-inline-border-bottom) !important;
}
[data-darkreader-inline-border-left] {
  border-left-color: var(--darkreader-inline-border-left) !important;
}
[data-darkreader-inline-border-right] {
  border-right-color: var(--darkreader-inline-border-right) !important;
}
[data-darkreader-inline-border-top] {
  border-top-color: var(--darkreader-inline-border-top) !important;
}
[data-darkreader-inline-boxshadow] {
  box-shadow: var(--darkreader-inline-boxshadow) !important;
}
[data-darkreader-inline-color] {
  color: var(--darkreader-inline-color) !important;
}
[data-darkreader-inline-fill] {
  fill: var(--darkreader-inline-fill) !important;
}
[data-darkreader-inline-stroke] {
  stroke: var(--darkreader-inline-stroke) !important;
}
[data-darkreader-inline-outline] {
  outline-color: var(--darkreader-inline-outline) !important;
}
[data-darkreader-inline-stopcolor] {
  stop-color: var(--darkreader-inline-stopcolor) !important;
}</style><style class="darkreader darkreader--variables" media="screen">:root {
   --darkreader-neutral-background: #000000;
   --darkreader-neutral-text: #938f8a;
   --darkreader-selection-background: #000b66;
   --darkreader-selection-text: #a2a19e;
}</style><style class="darkreader darkreader--root-vars" media="screen"></style><style class="darkreader darkreader--user-agent" media="screen">html {
    background-color: #000000 !important;
}
html {
    color-scheme: dark !important;
}
html, body {
    background-color: #000000;
}
html, body {
    border-color: #30291c;
    color: #a2a19e;
}
a {
    color: #004eb9;
}
table {
    border-color: #12191c;
}
::placeholder {
    color: #6e675d;
}
input:-webkit-autofill,
textarea:-webkit-autofill,
select:-webkit-autofill {
    background-color: #000300 !important;
    color: #a2a19e !important;
}
::-webkit-scrollbar {
    background-color: #000000;
    color: #676055;
}
::-webkit-scrollbar-thumb {
    background-color: #04080b;
}
::-webkit-scrollbar-thumb:hover {
    background-color: #151c20;
}
::-webkit-scrollbar-thumb:active {
    background-color: #060c0f;
}
::-webkit-scrollbar-corner {
    background-color: #000000;
}
* {
    scrollbar-color: #04080b #000000;
}
::selection {
    background-color: #000b66 !important;
    color: #a2a19e !important;
}
::-moz-selection {
    background-color: #000b66 !important;
    color: #a2a19e !important;
}</style>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GQZ_Asteroids</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
    }

    canvas {
      display: block;
      border: 1px solid white;
    }
  </style><style class="darkreader darkreader--sync" media="screen"></style>
<meta name="darkreader" content="a8913adb888146908f6eb83ba7839283"><style class="darkreader darkreader--override" media="screen">.vimvixen-hint {
    background-color: #381100 !important;
    border-color: #936c00 !important;
    color: #ada283 !important;
}
#vimvixen-console-frame {
    color-scheme: light !important
}
::placeholder {
    opacity: 0.5 !important;
}
#edge-translate-panel-body,
.MuiTypography-body1,
.nfe-quote-text {
    color: var(--darkreader-neutral-text) !important;
}
gr-main-header {
    background-color: #000007 !important;
}
.tou-z65h9k,
.tou-mignzq,
.tou-1b6i2ox,
.tou-lnqlqk {
    background-color: var(--darkreader-neutral-background) !important;
}
.tou-75mvi {
    background-color: #000000 !important;
}
.tou-ta9e87,
.tou-1w3fhi0,
.tou-1b8t2us,
.tou-py7lfi,
.tou-1lpmd9d,
.tou-1frrtv8,
.tou-17ezmgn {
    background-color: #000000 !important;
}
.tou-uknfeu {
    background-color: #000000 !important;
}
.tou-6i3zyv {
    background-color: #00152a !important;
}
div.mermaid-viewer-control-panel .btn {
  fill: var(--darkreader-neutral-text);
  background-color: var(--darkreader-neutral-background);
}
svg g rect.er {
  fill: var(--darkreader-neutral-background) !important;
}
svg g rect.er.entityBox {
  fill: var(--darkreader-neutral-background) !important;
}
svg g rect.er.attributeBoxOdd {
  fill: var(--darkreader-neutral-background) !important;
}
svg g rect.er.attributeBoxEven {
  fill-opacity: 0.8 !important;
  fill: var(--darkreader-selection-background);
}
svg rect.er.relationshipLabelBox {
  fill: var(--darkreader-neutral-background) !important;
}
svg g g.nodes rect, svg g g.nodes polygon {
  fill: var(--darkreader-neutral-background) !important;
}
svg g rect.task {
  fill: var(--darkreader-selection-background) !important;
}
svg line.messageLine0, svg line.messageLine1 {
  stroke: var(--darkreader-neutral-text) !important;
}
div.mermaid .actor {
  fill: var(--darkreader-neutral-background) !important;
}
embed[type="application/pdf"] { filter: invert(100%) contrast(90%); }</style></head>

<body>
  <canvas id="arrowCanvas" width="864" height="429"></canvas>

  <script>
    const canvas = document.getElementById('arrowCanvas');
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    const width = canvas.width;
    const height = canvas.height;
    let x = canvas.width / 2;
    let y = canvas.height / 2;
    let velocityX = 0;
    let velocityY = 0;
    let angle = Math.PI / 2;
    const arrowWidth = 10;
    const arrowHeight = 20;
    const thrustPower = 0.2;
    const brakePower = 0.005;
    const friction = 0.98;
    const projectileCooldownTime = 200;
    let projectileCooldown = 0;
    const projectiles = [];
    const projectileRadius = 1.5;
    const projectileSpeed = 2;
    const asteroids = [];
    const asteroidMaxSize = 32;
    const asteroidMinSize = 2;
    const maxFadeFrames = 20; // Adjust this value as needed
    let health = 100;
    let points = 0;
    let totalAsteroidMass = 0; // Added for total asteroid mass
    const keys = {};
    let lastTimestamp = 0;

    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);

    function handleKeyDown(e) {
      keys[e.key] = true;

      if ((e.key === ' ' || e.key === 'Shift' )&& Date.now() > projectileCooldown) {
        const projectile = {
          x,
          y,
          size: projectileRadius,
          velocityX: Math.cos(angle) * projectileSpeed * 2,
          velocityY: Math.sin(angle) * projectileSpeed * 2,
        };
        projectiles.push(projectile);
        projectileCooldown = Date.now() + projectileCooldownTime;
      }
    }

    function handleKeyUp(e) {
      keys[e.key] = false;
    }

    function update(timestamp) {
      

      if (timestamp - lastTimestamp < 1000 / 60) {
        return;
      }
      lastTimestamp = timestamp;

    //   ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle =`hsla(0,0%,0%, 0.1)`
        ctx.fillRect(-canvas.width, -canvas.height, canvas.width*2, canvas.height*2);


        //render()

      const cosAngle = Math.cos(angle);
      const sinAngle = Math.sin(angle);

      for (const asteroid of asteroids) {
        asteroid.age++;

        let fadeFactor = 1;
        if (asteroid.age < maxFadeFrames) {
          fadeFactor = asteroid.age / maxFadeFrames;
        }

        const grayColor = Math.floor(255 * fadeFactor);
        const borderColor = 10; // Black border

        ctx.beginPath();
        ctx.arc(asteroid.x, asteroid.y, asteroid.size, 0, Math.PI * 2);
        ctx.fillStyle = `rgb(${grayColor}, ${grayColor}, ${grayColor})`;
        ctx.strokeStyle = 'black';
        ctx.lineWidth = borderColor;
        ctx.fill();
        ctx.stroke();
        ctx.closePath();
      }

      for (const asteroid of asteroids) {
        if (asteroid.age >= maxFadeFrames) {
          asteroid.x = (asteroid.x + asteroid.velocityX + canvas.width) % canvas.width;
          asteroid.y = (asteroid.y + asteroid.velocityY + canvas.height) % canvas.height;
        }
      }

      for (let i = projectiles.length - 1; i >= 0; i--) {
        const projectile = projectiles[i];
        projectile.x += projectile.velocityX;
        projectile.y += projectile.velocityY;

        if (
          projectile.x < 0 ||
          projectile.x > canvas.width ||
          projectile.y < 0 ||
          projectile.y > canvas.height
        ) {
          projectiles.splice(i, 1);
        }
      }

      if (keys['ArrowUp'] || keys['w'] ) {
        velocityX += cosAngle * thrustPower;
        velocityY += sinAngle * thrustPower;
      }
      if (keys['ArrowDown'] || keys['s'] ) {
        velocityX *= 1 - brakePower;
        velocityY *= 1 - brakePower;
      }
      if (keys['ArrowLeft'] || keys['a'] ) {
        angle -= 0.075;
      }
      if (keys['ArrowRight']  || keys['d'] ) {
        angle += 0.075;
      }

      velocityX *= friction;
      velocityY *= friction;

      x = (x + velocityX + canvas.width) % canvas.width;
      y = (y + velocityY + canvas.height) % canvas.height;

      drawArrow();
      handleCollisions();
      updateAsteroids();
      updateProjectiles();
      showHUD();

       update()

                   // if (true) {
                     //   setTimeout(window.requestAnimationFrame, 15, update(timeStamp))
                  //  }

    }

    function drawArrow() {
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(angle);
      ctx.beginPath();
      ctx.moveTo(-arrowHeight / 4, -arrowWidth / 4);
      ctx.lineTo(-arrowHeight / 4, arrowWidth / 4);
      ctx.lineTo(arrowHeight / 4, 0);
      ctx.closePath();
      ctx.fillStyle = 'white';
      ctx.fill();
      ctx.restore();
    }

    function handleCollisions() {
      totalAsteroidMass = 0;

      for (let i = asteroids.length - 1; i >= 0; i--) {
        const asteroid = asteroids[i];
        totalAsteroidMass += asteroid.size; // Calculate total asteroid mass

        const distanceShipAsteroid = Math.hypot(x - asteroid.x, y - asteroid.y);

        // Check if the asteroid is done fading in
        if (asteroid.age >= maxFadeFrames) {
          if (distanceShipAsteroid < arrowWidth / 2 + asteroid.size / 2) {
            health -= 10;
            asteroids.splice(i, 1);
          }
        }

        for (let j = projectiles.length - 1; j >= 0; j--) {
          const projectile = projectiles[j];
          const distance = Math.hypot(projectile.x - asteroid.x, projectile.y - asteroid.y);

          // Check if the asteroid is done fading in
          if (asteroid.age >= maxFadeFrames) {
            if (distance < projectileRadius + asteroid.size) {
              splitAsteroid(asteroid);
              asteroids.splice(i, 1);
              projectiles.splice(j, 1);
              points += 10;
            }
          }
        }
      }
    }

    function updateAsteroids() {
      for (const asteroid of asteroids) {
        if (asteroid.age >= maxFadeFrames) {
          ctx.beginPath();
          ctx.arc(asteroid.x, asteroid.y, asteroid.size, 0, Math.PI * 2);
          ctx.fillStyle = 'gray';
          ctx.fill();
          ctx.closePath();
        }
      }
    }

    function updateProjectiles() {
      // Update projectile positions
      for (let i = projectiles.length - 1; i >= 0; i--) {
        const projectile = projectiles[i];
        projectile.x += projectile.velocityX;
        projectile.y += projectile.velocityY;

        // Remove projectiles that are out of bounds
        if (
          projectile.x < 0 ||
          projectile.x > canvas.width ||
          projectile.y < 0 ||
          projectile.y > canvas.height
        ) {
          projectiles.splice(i, 1);
        }
      }

      // Draw projectiles
      for (let i = 0; i < projectiles.length; i++) {
        const projectile = projectiles[i];
        ctx.beginPath();
        ctx.arc(projectile.x, projectile.y, projectile.size, 0, Math.PI * 2);
        ctx.fillStyle = 'red';
        ctx.fill();
        ctx.closePath();
      }
    }

    function showHUD() {
      // Draw health and points
      ctx.fillStyle = 'white';
      ctx.font = '20px Arial';
      ctx.fillText(`Health: ${health}`, 20, 30);

      // Display total asteroid sizes in the middle
      const totalAsteroidSizes = asteroids.reduce((sum, asteroid) => sum + asteroid.size, 0);
      ctx.fillText(`Debris: ${totalAsteroidSizes.toFixed(2)}`, canvas.width / 2 - 80, 30);

      ctx.fillText(`Points: ${points}`, canvas.width - 120, 30);

      // Draw projectile cooldown information
      const cooldownPercentage = Math.max(0, (projectileCooldown - Date.now()) / projectileCooldownTime);
      const cooldownColor = `rgb(${255 * (1 - cooldownPercentage)}, ${255 * cooldownPercentage}, 0)`;

      const barWidth = 100;
      const barHeight = 10;
      const barX = (canvas.width - barWidth) / 2;
      const barY = canvas.height - 40;

      // Draw white border
      ctx.fillStyle = 'white';
      ctx.fillRect(barX - 2, barY - 2, barWidth + 4, barHeight + 4);

      // Draw filled portion based on cooldownPercentage
      ctx.fillStyle = cooldownColor;
      ctx.fillRect(barX, barY, barWidth * cooldownPercentage, barHeight);
    }

    function spawnAsteroid() {
      const minPower = 1; // Minimum power of 2 (2^1)
      const maxPower = 5; // Maximum power of 2 (2^5)

      const power = Math.floor(Math.random() * (maxPower - minPower + 1)) + minPower;
      const size = Math.pow(2, power);

      const asteroid = {
        x: Math.random() * canvas.width,
        y: Math.random() * canvas.height,
        size: size,
        velocityX: Math.random() - 0.5,
        velocityY: Math.random() - 0.5,
        age: 0, // Initialize age to 0
      };

      asteroids.push(asteroid);
    }

    function splitAsteroid(asteroid) {
      if (asteroid.size > asteroidMinSize * 2) {
        for (let k = 0; k < 2; k++) {
          const newAsteroid = {
            x: asteroid.x,
            y: asteroid.y,
            size: asteroid.size / 2,
            velocityX: asteroid.velocityX + (Math.random() - 0.5),
            velocityY: asteroid.velocityY + (Math.random() - 0.5),
            age: maxFadeFrames, // Set age to maxFadeFrames for split asteroids
          };
          asteroids.push(newAsteroid);
        }
      }
    }

    function gradualAsteroidSpawn() {
      const maxMass = 100; // Adjust this value as needed
      const respawnRate = 0.5; // Adjust this value for respawn speed

      const currentMass = asteroids.reduce((sum, asteroid) => sum + asteroid.size, 0);

      // Calculate spawn rate based on the current mass and respawn rate
      const spawnRate = 1 - currentMass / maxMass;
      const adjustedSpawnRate = spawnRate * respawnRate;

      // Adjust spawn probability based on adjustedSpawnRate
      if (Math.random() < adjustedSpawnRate) {
        spawnAsteroid();
      }

      // Schedule the next asteroid spawn
      setTimeout(gradualAsteroidSpawn, 1000);
    }

    function spawnInitialAsteroids(count) {
      for (let i = 0; i < count; i++) {
        spawnAsteroid();
      }
    }







    spawnInitialAsteroids(3);
    requestAnimationFrame(update);
    gradualAsteroidSpawn();


  </script>



</body></html>